<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3.3. CONCEPTS</title><meta name="generator" content="DocBook XSL Stylesheets V1.66.1" /><link rel="start" href="index.html" title="Os9Disasm - A Cross Disassembler for the m6809" /><link rel="up" href="ch03.html" title="Chapter 3. Invoking and Running OS9Disasm" /><link rel="prev" href="ch03s02.html" title="3.2. The command file" /><link rel="next" href="thecmdfile.html" title="Chapter 4. The Command File in Detail" /><meta name="generator" content="Experimental LDP.XSL $Revision$" />
  <!-- Generated by LDP XSLT customization layer
      based on Norman Walsh's DocBook XSL stylesheets.
      More information at http://www.linuxdoc.org/ -->
  </head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3.3. CONCEPTS</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s02.html">Prev</a> </td><th width="60%" align="center">Chapter 3. Invoking and Running <span><b class="command">OS9Disasm</b></span></th><td width="20%" align="right"> <a accesskey="n" href="thecmdfile.html">Next</a></td></tr></table><hr /></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2528031"></a>3.3. CONCEPTS</h2></div></div></div><p>Before discussing the actual commands used to instruct <span><b class="command">OS9Disasm</b></span> to
      disassemble an object file, it is perhaps wise to study the various ways
      in which a file can be disassembled. In particular, it is important that
      the concepts of label classes, standard labels, offsets, and data areas
      be understood.
    </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2528052"></a>3.3.1. Label Class</h3></div></div></div><p>One of the more important jobs in disassembling a program is the
          proper generation of labels. This is the creation of a label name
          from an address, usually by preceding the address with a letter (e.g.
          address <span><b class="command">$1234</b></span> becomes
          <tt class="computeroutput">L1234</tt>).
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Our definition of a Label</h3><p>In this manual, 'label' refers to an assembler symbol,
            that is, a name beginning with an alphabetic character. This is not
            the same as the standard usage of the word in conjunction with
            assemblers.)
          </p></div><p>At its simplest, it would appear that a disassembler should
          generate a label whenever a memory reference is implied by an
          instruction, as in the instruction <tt class="computeroutput">LDA
          L1234</tt>. A little study, though, quickly shows how
          much more complicated the situation really is.
        </p><p>For instance, in an OS/9 program, consider the three
          instructions
        </p><table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">
          LDA &lt;$10   (direct)
          LDA &gt;$0010  (extended)
          BRA $0010      (relative),
        </pre></td></tr></table><p>All seem to refer to the same address <span><b class="command">$0010</b></span>,
          but in fact refer to three different memory locations. The direct
          reference is to an address in the module data area, the extended
          reference is to an absolute address in page 0 of memory, and the
          relative reference is to an address actually within the module.
          Obviously, a disassembler assigning the same label (e.g.
          <tt class="computeroutput">L0010</tt>) to all three instructions is
          quite limited in usefulness.
        </p><p>In order to allow a different label to be assigned in such
          cases, <span><b class="command">OS9Disasm</b></span> uses the concept of <span><b class="command">label classes</b></span>.
          Basically, a label class is simply the letter used as the first
          character in a generated label name.  Thus, if <span><b class="command">direct
          </b></span>references are assigned to the label class
          <tt class="computeroutput">D</tt>, <span><b class="command">extended</b></span>
          references to class <tt class="computeroutput">X</tt>, and
          <span><b class="command">program</b></span> (relative) references to class
          <tt class="computeroutput">L</tt>, then the three instructions above
          could be disassembled as <tt class="computeroutput">LDA X0010</tt>,
          and <tt class="computeroutput">BRA L0010</tt>. <span><b class="command">OS9Disasm</b></span> expands the
          use of label classes beyond the 26 basic classes
          <tt class="computeroutput">A</tt> to
          <tt class="computeroutput">Z</tt> to include the generation of
          various forms of data values or standard system defined names. There
          are 5 additional label classes, denoted by the special characters
          <span><b class="command">'$', '&amp;', '@', '^',</b></span>, '<span><b class="command">!</b></span>',
          and '<span><b class="command">%</b></span>. With these forms, operands may be
          disassembled as hexadecimal or decimal data, or as ASCII characters,
          or as the standard names, used by the OS/9 operating system in the
          OS9 opcode, or binary:
        </p><div class="informaltable"><table border="0"><colgroup><col /><col /></colgroup><tbody valign="top"><tr><td><span><b class="command">$</b></span></td><td><i class="emphasis">Generates a hexadeciamal constant </i>
            <span><b class="command">OS9Disasm</b></span> will generate a data value consisting of a dollar sign,
            '$', followed by either a four digit or a two digit hexadecimal
            number.The two digit form will be used, when possible, in operands
            which are one byte long (for instance, <tt class="computeroutput">
            LDA #$12)</tt>.
           </td></tr><tr><td><span><b class="command">&amp;</b></span></td><td><i class="emphasis">Generates a decimal constant.</i>
            <span><b class="command">OS9Disasm</b></span> will generate a signed decimal number. Only full 16 bit
            values with the highest bit set will be generated as negative
            numbers (negative indexed offsets will be sign extended).
           </td></tr><tr><td><span><b class="command">@</b></span></td><td><i class="emphasis">Generates a decimal or hex constant </i>
             If the value is from 0 to 9, then <span><b class="command">OS9Disasm</b></span> will generate a decimal
             constant, otherwise, it will generate a hexadecimal constant.
           </td></tr><tr><td><span><b class="command">^</b></span></td><td><i class="emphasis">Generates an ASCII constant. </i>
             The particular form which <span><b class="command">OS9Disasm</b></span> will generate depends upon the
             value of the constant. For a one byte value from $00 to $20, or
             $7F, <span><b class="command">OS9Disasm</b></span> will generate the standard name of the control
             character (<tt class="computeroutput">SPACE</tt> for $20,
             <tt class="computeroutput">DEL</tt> for $7f).  For a one byte
             value from $21 to $7E, <span><b class="command">OS9Disasm</b></span> will generate an ASCII constant
             consisting of an apostrophe (') followed by the ASCII graphic for
             that particular code value. For a one byte value from $80 to $FF,
             <span><b class="command">OS9Disasm</b></span> will generate the proper form for the value without the
             high bit set, appending an offset of +$80 (e.g.  disassemble
             <tt class="computeroutput">LDA #$C1</tt> as <tt class="computeroutput">LDA
             #'A+$80</tt>). For two byte values to be disassembled
             as an ASCII constant, <span><b class="command">OS9Disasm</b></span> will break the value apart into the
             two separate bytes, and generate each as a one byte ASCII
             constant, taking into account the possible presence of a parity
             bit on each byte. As an option, if both bytes are the codes for
             ASCII graphic characters, <span><b class="command">OS9Disasm</b></span> can generate a double ASCII
             constant consisting of a double quote (") followed by the two
             characters. Some examples: <tt class="computeroutput">LDD
             #$8D3F</tt> is disassembled as <tt class="computeroutput">LDD
             #CR*256+'?+$8000</tt>, <tt class="computeroutput">LDD
             #$4142</tt> is disassembled as <tt class="computeroutput">LDD
             #"AB</tt> (double ASCII enabled) or
             <tt class="computeroutput">LDD #'A*256+'B</tt> (double ASCII
             disabled).
           </td></tr><tr><td><span><b class="command">!</b></span></td><td><i class="emphasis">Generates a system function name. </i>
            When disassembling OS/9 code, <span><b class="command">OS9Disasm</b></span> will automatically use a
            standard name in the OS9 opcode. Thus, <span><b class="command">SWI2</b></span>,
            <span><b class="command">FCB $06</b></span> is disassembled as <span><b class="command">OS9
            F$Exit</b></span>. With the '<span><b class="command">!</b></span>' label class, odis
            will generate this standard system name (e.g.
            <span><b class="command">F$Exit</b></span> for $06) if such a standard name exists.
            If no standard system function name exists, then <span><b class="command">OS9Disasm</b></span> will
            generate a hexadecimal constant for the value.
           </td></tr><tr><td><span><b class="command">%</b></span></td><td><i class="emphasis">Generate a binary representation.</i>  This
            will generate a binary representation of the value of the operand.
            For example,<table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">lda #$f3</pre></td></tr></table> would generate
            <table border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">lda #%11110011</pre></td></tr></table>  It works with
            either 8-bit or 16-bit numbers.
          </td></tr></tbody></table></div><p>As a further example of the use of label classes, consider the
        instruction <tt class="computeroutput">LDA #$30</tt>. Under label
        classes <tt class="filename">'A', '$', '&amp;', '@'</tt>, and
        '<tt class="filename">!</tt>', the value $30 would be disassembled as
        <tt class="computeroutput">A0030</tt>,
        <tt class="computeroutput">$30</tt>,
        <tt class="computeroutput">48</tt>,
        <tt class="computeroutput">$30</tt>,
        <tt class="computeroutput">'0</tt>, and
        <tt class="computeroutput">F$All64</tt> respectively.
      </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="lclassdefined"></a>3.3.2. Label Classes Defined</h3></div></div></div><p>Given these 31 different label classes, you must have some way to
        specify which instructions are to use which label classes. <span><b class="command">OS9Disasm</b></span>
        accomplishes this by assigning label classes based on the addressing
        mode of the instructions in which they are to be used.
      </p><p>For instance, in the default OS/9 configuration
        </p><div class="itemizedlist"><ul type="disc"><li>direct page instructions are disassembled using
            label class <tt class="filename">D</tt></li><li>extended instructions are disassembled using label
            class <tt class="filename">X</tt></li></ul></div><p>
        <span><b class="command">OS9Disasm</b></span> recognizes 13 different addressing modes which have an
        operand consisting of a value, and therefore require a label
        class assignment to specify the proper form of label or data value to
        generate.
       </p><p>These 13 addressing modes are (with examples of each):
       </p><div class="informaltable"><table border="1"><colgroup><col /><col /></colgroup><tbody><tr><td>1 byte immediate</td><td><span><b class="command">LDA #$12</b></span>; <span><b class="command">ORCC #$FE</b></span>
               </td></tr><tr><td>D immediate</td><td><span><b class="command">ADDD #$1234</b></span></td></tr><tr><td>X immediate</td><td><span><b class="command">LDX #$0000</b></span></td></tr><tr><td>Y immediate</td><td><span><b class="command">CMPY #$A5A5</b></span></td></tr><tr><td>U immediate</td><td><span><b class="command">CMPU #$5678</b></span></td></tr><tr><td>S immediate</td><td><span><b class="command">LDS #$C000</b></span></td></tr><tr><td>X indexed</td><td><span><b class="command">STA 5,X; CLR ,X</b></span></td></tr><tr><td>Y indexed</td><td><span><b class="command">LDB $1234,Y</b></span></td></tr><tr><td>U indexed</td><td><span><b class="command">CMPD -52,U</b></span></td></tr><tr><td>S indexed</td><td><span><b class="command">LEAS -20,S</b></span></td></tr><tr><td>direct page</td><td><span><b class="command">STX $20</b></span></td></tr><tr><td>extended</td><td><span><b class="command">LDY $1234</b></span>; 
                <span><b class="command">JMP [$0030]</b></span></td></tr><tr><td>relative</td><td><span><b class="command">LBRA $1000</b></span>; 
                <span><b class="command">LEAX $0FF0,PCR</b></span></td></tr></tbody></table></div><p>Note that the relative addressing mode, for purposes of label
         generation, includes both branch instructions (<span><b class="command">BRA</b></span>,
         <span><b class="command">LBSR</b></span>, etc.) and <span><b class="command">PC</b></span> relative
         references. both of these forms usually refer to code within a single
         program or module, and are thus grouped together.
       </p><p>Note further the example, under the <span><b class="command">X</b></span> indexed
         addressing mode, of a zero offset indexed instruction.  Normally, no
         offset should be printed in such an instruction.
       </p><p>There are occasions, though, in which you might want a named
         offset, which is assembled to the zero offset form. For instance,
         suppose an index register points to the start of a data structure,
         each part of which should be given a label name. In that case, <span><b class="command">OS9Disasm</b></span>
         should generate a label name for a reference to the zero entry in the
         structure.  To take care of this problem, <span><b class="command">OS9Disasm</b></span> will automatically
         generate a label name for zero offset indexing if the label class for
         the instruction is one which generates a label ('A' to 'Z', '^', '!'),
         and will generate no offset if the label class is one which generates
         a data value ('$', '&amp;', '@').
       </p><p>The assignment of label classes to addressing modes is
         allowed by <span><b class="command">OS9Disasm</b></span> in three forms.
         </p><div class="orderedlist"><ol type="1"><li>The assignment can be made globally, so that all
             instructions with a particular addressing mode encountered in the
             object code are disassembled with one label class.
           </li><li>The assignment can be made for a range of program
             addresses. This is especially useful for indexed addressing
             modes. Often, an index register will point to a particular data
             structure only within a certain subroutines in a program, and
             the assignment of a label class for that structure should only
             be made for those subroutines.
           </li><li>The assignment can be made for a single instruction in
             the object code. This will often be used with the 1 byte
             immediate addressing mode, in which a single instruction refers
             to an ASCII value or some mask value (as in the <span><b class="command">ORCC
             </b></span> instruction). The actual method used to specify label
             classes by addressing modes is taken up under the discussion of
             the command file later in this manual.  See <a href="laddrmod.html" title="4.1. Label Addressing Mode Specification Command Line">Section 4.1, “Label Addressing Mode Specification Command Line”</a>.
           </li></ol></div><p>
       </p></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="id2529048"></a>3.3.3. Standard Labels</h3></div></div></div><p>
       As can be seen in the above section, <span><b class="command">OS9Disasm</b></span> can generate many labels
       within a program. These labels, though, formed by appending a label
       class letter to a four digit hexadecimal value, do not produce
       particularly meaningful names. It is possible, of course, to edit the
       output from <span><b class="command">OS9Disasm</b></span>, and globally change some default label name to
       something more meaningful, but this can be difficult if the program is
       very large, and is an error-prone process in any case.
     </p><p>Instead, it is more useful to specify to <span><b class="command">OS9Disasm</b></span>, before the
       disassembly, that all
       references to a certain label are to be output using some standard
       name.  This way, there is no need to do a later edit, and there is no
       chance of
       accidentally missing a reference to a label in the program.
     </p><p>You have already encountered, in the previous section, this
       substitution of standard names for labels. When the ASCII label class is
       specified for a value or $20, for instance, the name
       '<tt class="computeroutput">SPACE</tt>' is generated. Also, the system
       function name label class, '!', will generate standard names for certain
       values, e.g.  F$Link for $00.
     </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2529107"></a>3.3.3.1. Generating your own Label names</h4></div></div></div><p>With the standard label abilities of <span><b class="command">OS9Disasm</b></span>, you can generate
         your own standard names (in fact, it is possible to use your own
         standard names for ASCII control characters of system functions).
       </p><p>One use of standard labels is simply giving meaningful names to
         references to program lines or data area variables.  For instance,
         it is possible to take the <tt class="computeroutput">MOD</tt>
         statement at the start of an OS/9 module, which might, without
         standard labels, look like
       </p><p>
        <table xmlns="http://www.w3.org/TR/xhtml1/transitional" border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">MOD L1000,L000D,$C1,$81,L0050,D0200</pre></td></tr></table>
       </p><p>and, by assigning standard labels, give it the much more
        readable form
       </p><p>
        <table xmlns="http://www.w3.org/TR/xhtml1/transitional" border="0" bgcolor="#E0E0E0" width="90%"><tr><td><pre class="programlisting">MOD LENGTH,NAMEPTR,$C1,$81,ENTRY,DATASIZE
        </pre></td></tr></table>
       </p><p>
         Another use of standard labels is to give useful names to such values
         as bit masks or code values in immediate addressing mode instructions.
       </p><p> By assigning the standard name <tt class="computeroutput">CARRY
         </tt> to the value $01, label class
         <tt class="computeroutput">C</tt>, and then assigning label class
         <tt class="computeroutput">C</tt> to a single 1 byte immediate
         instruction <tt class="computeroutput">ORCC #1</tt>, the instruction
         would be disassembled as <tt class="computeroutput">ORCC #CARRY</tt>,
         obviously a much clearer form.
       </p><p>As can be seen in the above examples, there are two things which
         must be specified when giving a label a standard name. A standard
         label has both a value and a label class.  Thus, in the
         <tt class="computeroutput">MOD</tt> statement, the name
         <tt class="computeroutput">LENGTH</tt> is assigned to the value $1000
         and the label class <tt class="computeroutput">L</tt>. The actual
         specification of standard labels is detailed in the section on label
         files - <a href="labelfile.html" title="4.3. The Label File">Section 4.3, “The Label File”</a>.
       </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="offsets"></a>3.3.4. Offsets</h3></div></div></div><p> 
        Occasionally, when a routine searches through a data table, it will
        start the search by loading an index register with an address which is
        less than the address of the actual table. For instance, a search of a
        table at address $1000 might start by loading <span><b class="command">X</b></span> with
        the address $0FFF. When this is disassembled, you want a label to be
        generated for the value $1000 instead of the value $0FFF. To do this,
        <span><b class="command">OS9Disasm</b></span> allows the use of offsets, so that an instruction may be
        disassembled as, say <tt class="computeroutput">LEAX L1000-1,PCR</tt>
        instead of <tt class="computeroutput">LEAX L0FFF,PCR</tt>.
      </p><p>
        There are times when a positive offset is also useful. Suppose a two
        byte variable is declared within the data area of an OS/9 module. That
        the variable is two bytes long might be obvious by the use of
        <tt class="computeroutput">LDD</tt> or
        <tt class="computeroutput">STX</tt> instructions in referring to it.
        The program may, though, sometimes refer to only the second byte of the
        variable. Rather than assigning a separate label to this second byte,
        the program is much cleaner and clearer if the second byte is referred
        to by the name given the first byte with an offset of 1, e.g.
        <tt class="computeroutput">D0020+1</tt> instead of
        <tt class="computeroutput">D0021</tt>.
      </p><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="id2529324"></a>3.3.4.1. More complex offsets</h4></div></div></div><p>While most offsets are one of these simple forms, a small offset
          to be printed as plus or minus some decimal value, <span><b class="command">OS9Disasm</b></span> also
          allows more complicated variations.
        </p><p>When specifying an offset to be used in an instruction, <span><b class="command">OS9Disasm</b></span>
          allows you to specify both the value
          of the offset, whether it is to be added or subtracted, and the label
          class to be assigned to the offset. As an example, take the
          instruction <tt class="computeroutput">ORCC #$50</tt>. Assign class
          <span><b class="command">C</b></span> standard names <span><b class="command">FIRQM</b></span> to $40,
          <span><b class="command">IRQM</b></span> to $10, and assign class <span><b class="command">C</b></span>
          label generation for the instruction.  Finally, specify an offset of
          <span><b class="command">+$10</b></span> for the instruction, with class
          <span><b class="command">C</b></span> for the offset value. The resultant disassembled
          instruction would be <tt class="computeroutput">ORCC
          #FIRQM+IRQM</tt>.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>That the label class of the operand value and that of the
          offset need not be the same. Thus, it is possible to disassemble the
          instruction <tt class="computeroutput">LDA #40</tt> as
          <tt class="computeroutput">LDA #'A-1</tt> by specifying an operand
          label class of <span><b class="command">^</b></span> (ASCII), and a subtracted offset
          of 1 with a label class of <span><b class="command">&amp;</b></span> (decimal).</p></div><p>There is one further offset form which you can instruct <span><b class="command">OS9Disasm</b></span>
          to use. This
          is program counter offset. By using
          <tt class="computeroutput">PC</tt> offset, instructions can be
          disassembled with the form <tt class="computeroutput">LEAX
          L1000-*,Y</tt>. A <span><b class="command">PC</b></span> offset is always
          subtracted from the operand, and may be mixed with a constant offset.
          This is most useful in data areas (<a href="dataaddr.html" title="4.2. Data Area Boundary Specification Command Line">Section 4.2, “Data Area Boundary Specification Command Line”</a>).
        </p><p>For instance, when using the OS/9 system calls <span><b class="command">F$SSvc
          </b></span>, a data table is
          required which includes an entry giving the offset of a service
          routine from the byte following the entry. This is best disassembled
          as, say <tt class="computeroutput">FDB L1000-*-2</tt>, which is
          simply a long label data element, class <span><b class="command">L</b></span>, with
          <span><b class="command">PC</b></span> offset and a decimal class negative offset of
          2. The specification of offsets to be used in executable code is
          explained in the section on the command file. This specification is
          done as part of the assignment of label classes to addressing modes.
          Offsetting is also possible within data areas, and is discussed in
          the next section, as well as in <a href="thecmdfile.html" title="Chapter 4. The Command File in Detail">Chapter 4, <i>The Command File in Detail</i></a>.
        </p></div></div><div class="section" lang="en" xml:lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="datadescr"></a>3.3.5. Data Areas</h3></div></div></div><p>Few programs to be disassembled consist entirely of executable
        code.  Most programs will include some areas which are to be
        disassembled as data.
      </p><p>For instance, there may be ASCII strings or tables of bytes
        within a program. <span><b class="command">OS9Disasm</b></span> gives you complete control over the
        specification of data areas within the program.
      </p><p>Five basic data area types lie at the heart of this control.
        These types are also discussed at <a href="ch03s02.html#databounds" title="3.2.1. Data bounds">Section 3.2.1, “Data bounds”</a>. In
        addition, to these basic types, you may specify both PC and constant
        offsets to be applied to the data.
      </p><p>
       ASCII data areas are those which contain ASCII characters, and should be
       disassembled using <span><b class="command">FCC</b></span> or <span><b class="command">FCS</b></span>
       statements, if possible. Graphic ASCII characters are collected together
       and output in <span><b class="command">FCC</b></span> or <span><b class="command">FCS</b></span> statements,
       with a double quote (") delimiter. The <span><b class="command">FCS</b></span> statement
       will be used, if enabled (it can be optionally disabled), whenever a
       character with the high bit set.  Nongraphic ASCII characters, which
       include the control characters, <span><b class="command">DEL</b></span> ($7F), and
       characters with the high bit set (if <span><b class="command">FCS</b></span> is disabled),
       will be output in <span><b class="command">FCB</b></span> statements, with the same format
       as that described in the ASCII label class.
     </p><p>Byte data areas are disassembled using <span><b class="command">FCB</b></span>
       statements, with two digit
       hexadecimal operands.  Byte data areas are equivalent to short label data
       areas with a label class of '<span><b class="command">$</b></span>' (hexadecimal).
     </p><p>Long label data areas are disassembled using <span><b class="command">FDB
       </b></span> statements, with operands whose form depends on the label
       class to be used.  Thus, when specifying long label areas, you must also
       specify which of the 31 label classes is desired. Long label data is
       often used, with class <span><b class="command">L</b></span>, to hold addresses of
       routines within a program, for multiple direction jumps. These tables
       will also often use PC offsets or a constant class <span><b class="command">L</b></span>
       offset (<span><b class="command">FDB L1234-*</b></span> or <span><b class="command">FDB
       L1234-L1000</b></span>).
     </p><p>Short label data areas are disassembled using <span><b class="command">FCB
       </b></span> statements, and also require a label class to be specified.
       Short labels are less often used for program labels, but are often used
       for direct page labels, code values, or bit masks. It is also possible,
       using the ASCII label class, to set up ASCII constants separated out
       letter by letter. For instance, a four byte long ASCII data area may be
       disassembled as <tt class="computeroutput">FCS "ABCD"</tt>, while the
       same four bytes disassembled as short labels with label class ASCII
       would be disassembled as <span><b class="command">FCB 'A, 'B, 'C, 'D+$80</b></span>. This
       is occasionally useful.
     </p><p>Word data areas are disassembled using <span><b class="command">FDB</b></span>
       statements, with four digit hexadecimal operands.  Word data areas are
       equivalent to long label data areas with a label class or
       '<span><b class="command">$</b></span>' (hexadecimal).
      </p><p>Obviously, the proper selection of all the many forms of label
        classes, standard labels, offsets, and data areas can be quite
        difficult.  It requires a careful examination of the disassembled
        output, so that at least two complete disassemblies are required (often
        more). In return, though, it is possible to disassemble a large
        program, and have as output a file requiring no extensive editing,
        except for the adding of your own comments. A thorough use of standard
        labels and label class specifications will result in output filled with
        meaningful operands, so that the real work of understanding a
        disassembled program, that of deciphering the algorithms used instead
        of the opcodes used, is much easier.
      </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="thecmdfile.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">3.2. The command file </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 4. The Command File in Detail</td></tr></table></div></body></html>
