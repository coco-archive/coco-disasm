<section id="thecmdfile">
 <title>The Command File in Detail</title>
 <note><formalpara><title>Spacing is not critical anywhere in this file
     </title>
     Spacing within a command is not critical.  It is recommended that you
     separate most of the fields by at least one space,but can include any
     number of spaces between any distinct elements.
   </formalpara>
 </note>
 <para>The <filename>command file</filename>, specified by option
   <command>-c</command> on the command line, is a text file consiting of
   commands that affect the mode of disassembly. These commands determine the
   <literal>label class</literal> that an assembly instruction, or a range of
   instructions of a given type will be disassembled. There are five different
   types of commands:
 </para>
 <variablelist>
   <varlistentry>
     <term><computeroutput>Command Line Comments</computeroutput></term>
     <listitem>
       <para>A comment line can be inserted by beginning it with an asterisk
         (*).  These lines will be ignored by &odis; when processing.
       </para>
     </listitem>
   </varlistentry>
   <varlistentry>
     <term><computeroutput>Assembler Comment Lines</computeroutput></term>
     <listitem>
       <para>Comments can be inserted into the Listing output and the source
         output by beginning the line with a double quote (").  This must
         be followed by the label class, and then the address in hexadecimal.
         Any alpha characters can be either uppercase or lowercase,  The
         label class can be preceded and followed by any number of
         whitespaces (spaces or tabs), or none.  The address can be any value
         within the range of the command or equate, or whatever.  That is,
         suppose you have this code snippet

         <screen>
           101  0051 8e   ff48                 ldx    #$ff48
           102  0054 86   d0                   lda    #$d0
         </screen>
         and you want to add a comment for the command at 0051.  You could
         specify the address as any of 0051, 0052, or 0053.  Also, multiple
         entries for a given address will result in all the entries being
         inserted, in the order in which they are encountered in the command
         file.  They will, however, be processed in order of address.  For
         the above example, if you have a comment for 0051, then a comment
         for 0052, and later, another comment for 0051, then both comments
         for 0051 will be printed before the comment specified for 0052.
       </para>
       <para>The next character following the address will be the delimiter
         for the comment.  Unless this delimiter is <emphasis>the very
         last character on the line</emphasis>, immediately followed by
         the newline, then <emphasis>all succeeding lines in the command file
         will be processed as comments until a line ended with the specified
         delimiter is encountered</emphasis>.  This delimiter can be used
         within the comment as long as it is not the last character on the
         line.  The delimiter can be included as the last character of the
         comment simply by doubling this character at the end of the line.
         If multiple comment lines are used, each line from the command file
         will be an individual line in the listing.
       </para>
       <para><note>A blank line (with only an asterisk) in the listing can be
         generated by inserting a comment at the desired address and
         specifying an empty line with a pair of delimiters side by side.
         </note>
       </para>
     </listitem>
   </varlistentry>
   <varlistentry>
     <term><computeroutput>Option Command Lines</computeroutput></term>
      <listitem>
        <para>An option line is a line with a plus (+) sign in column one,
          followed by a list of option parameters. These options are the sames
          as those you would use on the command line. Any will work here exept,
          of course, the <command>c</command> option. The reason for this is
          that this option would have to have been used to be reading this file
          in the first place, and only one command file is permitted.
        </para>
        <para>It's quite useful to embed options into this file in order to
          eliminate the need to include them on the shell command line each
          time &odis; is executed.  You can enter as many options as you like
          on a single line, separated by a space, or you can include multiple
          options command lines.
        </para>
     </listitem>
   </varlistentry>
   <varlistentry>
     <term><computeroutput>
       Label Addressing Mode Specification Command Line
     </computeroutput></term>
     <listitem>
       <para>This defines the addressing mode by which this address or
         address range are specified.  See <xref linkend="laddrmod"/> for
         a detailed explanation of this concept.
       </para>
     </listitem>
   </varlistentry>
   <varlistentry>
     <term><computeroutput>Data Area Boundary Specification Command Line
     </computeroutput></term>
     <listitem>
       <para>Definitions for areas that are data, and not code.  Please refer
         to <xref linkend="dataaddr"/> for more details on this.
       </para>
     </listitem>
   </varlistentry>
 </variablelist>
 <section id="laddrmod">
   <title>Label Addressing Mode Specification Command Line</title>
   <para>The label addressing mode line is used to assign a certain label class
     to an addressing mode, as described in the previous section regarding
     label classes. The line starts with a 'greater than sign' (&gt;) in column
     one, followed by individual label addressing mode specifications,
     separated by semicolons if more than one specification is entered onto a
     single line. The format for a specification is:
   </para>
     <screen><literal>
      &lt;mode&gt; &lt;class&gt; [&lt;offset&gt;] &lt;range&gt;
     </literal></screen>
   <para>The addressing modes are:</para>
   <informaltable frame="none">
     <tgroup cols="2">
       <colspec colwidth="1.0in"/>
        <tbody valign="top">
         <row>
           <entry><command>#1</command></entry>
           <entry>1 byte immediate (any register)</entry>
         </row>
         <row>
           <entry><command>#D</command></entry>
           <entry>Immediate with ACCD</entry>
         </row>
         <row>
           <entry><command>#X</command></entry>
           <entry>Immediate with IX</entry>
         </row>
         <row>
           <entry><command>#Y</command></entry>
           <entry>Immediate with IY</entry>
         </row>
         <row>
           <entry><command>#U</command></entry>
           <entry>Immediate with U</entry>
         </row>
         <row>
           <entry><command>#S</command></entry>
           <entry>Immediate with S</entry>
         </row>
         <row>
           <entry><command>X</command></entry>
           <entry>Indexed by IX</entry>
         </row>
         <row>
           <entry><command>Y</command></entry>
           <entry>Indexed by IY</entry>
         </row>
         <row>
           <entry><command>U</command></entry>
           <entry>Indexed by U</entry>
         </row>
         <row>
           <entry><command>S</command></entry>
           <entry>Indexed by SP</entry>
         </row>
         <row>
           <entry><command>D</command></entry>
           <entry>Direct Page</entry>
         </row>
         <row>
           <entry><command>E</command></entry>
           <entry>Extended addressing mode</entry>
         </row>
         <row>
           <entry><command>R</command></entry>
           <entry>Relative (including indexed by PC)</entry>
         </row>
       </tbody>
     </tgroup>
   </informaltable>
   <para>The &lt;class&gt; is the label class to be used in generating the
     operand. This is one of '<command>A</command>' to '<command>Z</command>',
     '<command>$</command>', '<command>&amp;</command>', '<command>@</command>',
     '<command>^</command>', or '<command>!</command>' The &lt;offset&gt; is
     optional, used only if the operand is to be generated using one of the
     offset forms. The offset has the format:
   </para>
   <screen>
     '(' [ '*' ] [ ('+'| '-' ) &lt;class&gt; &lt;value&gt; ] ')'
   </screen>
   <para>The offset specification, if used, starts with a left parenthesis.
     If a program counter offset is to be used, an asterisk must come next. If a
     constant offset is to be used, then a plus sign or a minus sign must
     follow, indicating that the operand is disassembled as
     <command>LABEL+VALUE</command> or <command>LABEL-VALUE</command>. The label
     class to be used in generating the offset value comes next. Remember that
     this is not necessarily the same as the label class used in generating the
     actual value. The final part for a constant offset is the actual value.
     This should be a hexadecimal number, even if the decimal label class is
     specified. A right parenthesis ends the entire optional offset.
   </para>
   <para>The &lt;<literal>range</literal>&gt; specifies the range of
     addresses in which the specification is to take effect. This can take one
     of three forms. First, no range may be specified, in which case, the
     specification is to be applied globally within the program. Second,a single
     hexadecimal address indicates that the specification is to be applied to a
     single instruction only. In this case, the address should be that of the
     first byte of the instruction.  Finally, two hexadecimal addresses
     separated by a minus sign (<literal>&lt;addr&gt;-&lt;addr&gt;</literal>)
     indicates that the specification is to be applied to all instructions
     within the indicated address range which have the proper addressing mode.
     </para> <para>Below are some examples of label addressing mode
     specification lines, along with example disassembed lines for each
     specification:
   </para>
   <note>
     <para>Spacing is not critical in any of these, although at least one space
       (or tab) is required between each field in a single command.  In the
       case of the class and offset, you can merge them together or separate
       them.  Also note that all addresses <emphasis>MUST</emphasis> be in
       hexadecimal.
     </para>
   </note>
   <informaltable>
     <tgroup cols="2">
       <tbody>
         <row>
           <entry><command>&gt; #X L</command></entry>
           <entry><simplelist>
             <member><command>LDX #L0100</command></member>
           </simplelist></entry>
         </row>
         <row>
           <entry><command>&gt; D D 0-FFFF; E X</command></entry>
           <entry><simplelist>
             <member><command>ADDA D0012</command></member>
             <member>STA X1234</member>
           </simplelist></entry>
         </row>
         <row>
           <entry><command>&gt; #1 ^ 1000</command></entry>
           <entry><simplelist>
             <member><command>LDA #CR</command> (instruction at address $1000)
             </member>
           </simplelist></entry>
         </row>
         <row>
           <entry><command>&gt; X Q (*) 2000-27FF</command></entry>
           <entry><simplelist>
             <member><command>CLR Q3000-*</command> (instruction between
               $2000-$27FF
             </member>
           </simplelist></entry>
         </row>
         <row>
           <entry><command>&gt; S &amp; ; U A (*) ; X B (+X1000) ;
             Y C (*-$1000)</command>
           </entry>
           <entry><simplelist>
             <member><command>NEGB 4,S</command></member>
             <member><command>NEGB A0005-*,u</command></member>
             <member><command>NEGB BF005*X1000,X</command></member>
             <member><command>NEGB C1005-*-$1000,Y</command></member>
           </simplelist></entry>
         </row>
         <row>
           <entry><command>&gt; #1^(-&amp;10)</command></entry>
           <entry><simplelist>
             <member><command>LDB #'A-16</command></member>
           </simplelist></entry>
         </row>
       </tbody>
     </tgroup>
   </informaltable>
   <para>The default label class for each addressing mode depends on the
     object code format chosen. For the OS/9 and Motorola formats (options
     <computeroutput>MO</computeroutput> or <computeroutput>MM</computeroutput>)
     these are
   </para>
   <para><simplelist type="horiz">
     <member><command>&gt; #1 @ ; D @ ; #X @ ; #Y @ ; #U @ ; #S X
     </command></member>
     <member><command>&gt; X &amp;;Y &amp;;U D;S &amp;;D D;E X;R L
     </command></member>
   </simplelist></para>
   <para>Note that the <computeroutput>U</computeroutput> indexed and direct
     page addressing modes are assigned to the same label class. This reflects
     the standard usage of the <computeroutput>U</computeroutput> register under
     the OS/9 operating system, in which <computeroutput>U</computeroutput>
     points to the start of the data area.
   </para>
   <note>
     <para>For <literal>OS9</literal> programs compiled by the C compiler,
       it's a good idea to issue the command
    </para>
    <screen><command>&gt; Y D</command>,</screen>
    <para>and do it early in the command file.  This will set
      <literal>Y</literal> addressing class to <literal>D</literal> globally.
      The addressing mode of <literal>Y </literal> references can still be set
      to something else for isolated instances in the program.  It is desirable
      to set <command>Y</command> addressing class to this because the C
      compiler uses the <command>Y</command> register for the data area rather
      than the <command>U</command> register.  It is good in this case, also,
      to globally change the <command>U</command> addressing mode to something
      else, since it's obvious that the <command>U</command> register will not
      be used for data refs.
    </para>
   </note>
   <para>Programs assembled under <computeroutput>CoCo DOS</computeroutput> or
     <computeroutput>FLEX</computeroutput> are not usually written to be
     position independent, and are written to run at a specific address, so the
     default label classes for the <computeroutput>CoCo DOS</computeroutput> and
     <computeroutput>Flex</computeroutput> formats (options
     <computeroutput>MC</computeroutput> or
   <computeroutput>MF</computeroutput>) are
   </para>
   <para><simplelist type="horiz">
   <member><command>&gt; #1 @ ; #D @ ; #X L ; #Y L ; #U L ; #S L
   </command></member>
   <member><command>&gt; X &amp; ; Y &amp; ; U &amp; ; S &amp; ;D D ; E L ; R L
   </command></member>
   </simplelist></para>
   <para>&odis; uses the global label class for the relative addressing mode
     when generating symbols which are placed in the label field of disassembled
     program code. By default, this is label class
     <computeroutput>L</computeroutput>. To change the label class used for
     these internal program labels, a label addressing mode line specifying a
     global range label assignment to the relative addressing mode should be
     used. For instance, the line '<computeroutput>&gt; R S</computeroutput>'
     would force &odis; to use label class <computeroutput>S</computeroutput>
     labels as internal program labels. For this change to occur, though, there
     must be no range specification in the line (global range). It is also
     possible, if somewhat useless, to turn off the generation of internal
     program labels by globally assigning a data label class to the relative
     addressing mode globally, e.g.  '<computeroutput>&gt; R
     $</computeroutput>'.
   </para>
   <para>Finally, if in OS/9 object mode (option
     <computeroutput>MO</computeroutput>), and if a data area is to be
     disassembled, &odis; will do so using <computeroutput>RMB</computeroutput>
     statements instead of <computeroutput>EQU</computeroutput> statements, and
     will use the global label class for the direct page addressing mode when
     generating the data area label names. This defaults to class
     <computeroutput>D</computeroutput>. This can be modified in the same manner
     as that used to modify the default mode for internal program labels.
   </para>
 </section>
 <section id="dataaddr">
   <title>Data Area Boundary Specification Command Line</title>
   <para>The last type of command line is the data boundary specification line.
     This line is used to declare the addresses of data boundaries.  This line
     does not start with any particular character. Instead, &odis; assumes that
     any line beginning with any non-blank alphanumeric character is a data
     boundary specification line.  The line can consist of one or more
     individual data boundary specifications, with multiple specs separated by
     semicolons. The format of each specification is:
   </para>
   <screen>
     <literal>
       &lt;type&gt; [&lt;class&gt;] [&lt;offset&gt;] &lt;range&gt;
     </literal>
   </screen>
   <formalpara>
     <title>The format for the <command>=</command> specification is a
       bit different.
     </title>
     We'll mention this option here, since it is related.  However, there
     are some differences between this option and the general data boundary
     options.
   </formalpara>
   <para>
     <screen>
       <literal> = &lt;vsect&gt; &lt;range&gt; </literal>
     </screen>
   </para>
   <para><computeroutput>vsect</computeroutput> is one of
     '<computeroutput>d</computeroutput>' for direct page, or
     '<computeroutput>n</computeroutput>' for non-dp data.
   </para>
   <para>The <type>type</type> is the code for the data area type, which
     is one of the characters '<computeroutput>A</computeroutput>',
     '<computeroutput>B</computeroutput>',
     '<computeroutput>C</computeroutput>',
     '<computeroutput>L</computeroutput>',
     '<computeroutput>S</computeroutput>', or
     '<computeroutput>W</computeroutput>'.  
     The data area types <computeroutput>L</computeroutput> or
     <computeroutput>S</computeroutput> must be followed by a label class.
   </para>
   <para>The optional <literal>offset</literal>, coming next, is used when
     specifying an offset to be applied to each data element in the data area.
     The format of the <literal>offset</literal> specification is identical to
     that used in the label addressing mode specification line.
     <literal>offset</literal> is not available for
     '<computeroutput>=</computeroutput>' mode.
   </para>
   <para>The <literal>range</literal> specifies the range of addresses to be
     used, and is composed of two parts, the starting address and the ending
     address. In its simplest form, the <literal>range</literal> takes the form
     <literal>addr1-addr2</literal>, where <literal>addr1</literal> and
     <literal>addr2</literal> are <emphasis>hexadecimal</emphasis> numbers
     (without '<literal>$</literal>') specifying the address range. In its full
     form, the starting address may be either a hex number or null, in which
     case the starting address will be one more than the previous ending
     address (which must be well-defined), and the ending address may take any
     of four forms (some not available for<literal>=</literal> mode):
   </para>
     <informaltable>
       <tgroup cols="2">
         <tbody>
           <row>
             <entry align="center"><literal>null</literal></entry>
             <entry>The data area is only 1 byte long (2 for L or W data areas)
             </entry>
           </row>
           <row>
             <entry><literal>-addr2</literal></entry>
             <entry>The range continues to addr2
             </entry>
           </row>
           <row>
             <entry align="center"><literal>-</literal></entry>
             <entry>This is a dash by itself. The ending address will be one
               less than the starting address of the next data area. For this
               to work, the next boundary declaration must exist, and have a
               starting address which is not null.
             </entry>
           </row>
           <row>
             <entry><literal>/length</literal></entry>
             <entry>This is a decimal number, specifying the number of bytes in
               the data area. The ending address is computed as starting
               address+length-1
             </entry>
           </row>
         </tbody>
       </tgroup>
     </informaltable>
   <note><para>
       As previously said, only some modes are available with
       <literal>=</literal>mode.  The available modes are
       <literal>start-end</literal> and <literal>start/length</literal>.
   </para></note>
   <para> Below are some example data boundary specifications, with the
     effects of each:
   </para>
   <note>
     <para>Spacing, again, here, is not critical.  Just be sure at least one
       whitespace follows a numeric field (ranges don't matter). Colons can
       have have spaces or not.
     </para>
     <para>
       <command>Be sure to express all values in hexadecimal!</command>
     </para>
   </note>
   <variablelist>
     <varlistentry>
       <term><computeroutput>B 1000-10FF</computeroutput></term>
       <listitem><para>$1000 to $10FF delimit a byte of data</para></listitem>
     </varlistentry>
     <varlistentry><term>
       <computeroutput>
         B 2000-; S D 2040-207F; A -; W 2100/16
       </computeroutput></term>
       <listitem><simplelist>
         <member>$2000 to $203F delimit a byte data area</member>
         <member>$2040 to $207F delimit a list of short class D labels</member>
         <member>$2080 to $20FF delimit an ASCII data area.</member>
         <member>$2100 to $$210F delimit a word data area</member>
      </simplelist></listitem>
     </varlistentry>
     <varlistentry>
       <term><computeroutput>LL (-L1000) 1000/16</computeroutput></term>
        <listitem>
          <para>$1000 to $100F consists of 8 class
            <computeroutput>L</computeroutput> labels, each of which is offset
            by the value $1000. The offset is printed as a class
            <computeroutput>L</computeroutput> label.
          </para>
        </listitem>
     </varlistentry>
     <varlistentry>
       <term><computeroutput>B 1000-10FF</computeroutput></term>
       <listitem><para>$1000 to $100F delimit a byte data area.</para>
       </listitem>
     </varlistentry>
     <varlistentry>
       <term><computeroutput>= n 04/6</computeroutput></term>
       <listitem><para>The initialized bytes in the non-dp vsect from
           $0004 to $0009 (six bytes) will be displayed as ASCII data.
       </para></listitem>
     </varlistentry>
     <varlistentry>
       <term>
         <computeroutput>B 2000- ; S D 2040-207F ; A - ; W
         2100/16</computeroutput>
       </term>
       <listitem><simplelist>
         <member>2000 to $203F delimit a byte data area.</member>
         <member>$2040 to $207F delimit a list of <literal>short</literal>
           class <computeroutput>D</computeroutput> labels.
         </member>
         <member>$2080 to $20FF delimit an <literal>ASCII</literal> data area.
         </member>
         <member>$2100 to $$210F delimit a <literal>word</literal> data area.
         </member>
       </simplelist></listitem>
     </varlistentry>
   </variablelist>
   <para>Optionally the entire data area boundary specification line may be
     started with a repeat count. This is a decimal number which specifies the
     number of times the boundary specifications in the line are to be
     repeated.This is indispensable when disassembling large data tables which
     consistof individual entries made up of several different data types.
   </para>
   <para>For instance, suppose a table is made up of 25 entries, each of
     which consists of a single byte to be output as a decimal value, three
     ASCII characters, and two bytes to be output as a class 
     <computeroutput>L</computeroutput> label, offset by
     the program counter. The data elements in this complex form can be
     specifiedwith the single line
   </para>
   <para><computeroutput>25 S &amp; ; A / 3 ; L L (*)</computeroutput>
   </para>
   <para>Some points become clear when examining such a line with a repeat
    count. First, if a repeat count is used, then the ranges of all individual
    specifications within the line may not use any absolute addresses. The
    starting address may use only the null form, and the ending address may only
    use the null form or the '<computeroutput>/length</computeroutput>' form.
    Second, some method is required to specify the actual address at which the
    specifications are to be applied. This is where the
    <computeroutput>C</computeroutput>, or <literal>Code</literal>, 'data' type
    is useful. The table address may be supplied by preceding the table
    specification line with a line declaring the byte just before the table as
    code. The address can also be supplied by splitting up the specifications
    into two lines, the first of which declares the first entry at a certain
    address, the second of which declares the remainder of the table. Thus, if
    the table under consideration starts at address $1000, the specification may
    take the form:
   </para>
   <para><computeroutput>
    C 0FFF      25 S &amp; ; A /3 ; L L (*)
   </computeroutput></para>
   <para>or it may take the form</para>
   <para><computeroutput>
    S &amp; 1000 ; A /3 ; L L (*)      24 S &amp; ; A /3 ; L L (*)
   </computeroutput></para>
   <para>When a repetitive pattern is encountered, the above-described
    capability saves a lot of repetitious command entry.
   </para>
 </section>
 <section id="labelfile"><title>The Label File</title>
  <para>&odis; label files are used to supply the equivalence between label
   value/class combinations and the standard name by which that label is to be
   referenced. In the absence of a standard name, the label generated for a
   particular value will consist of the label class letter,
   <computeroutput>A</computeroutput> to <computeroutput>Z</computeroutput>,
   followed by the four hexadecimal digits of the value. Thus, an extended
   reference to address $1234 in the program will produce the label
   '<computeroutput>X1234</computeroutput>'. To change this label to something
   which reflects the function of the label in the program, a standard name can
   be used.
  </para>
  <formalpara><title>Standard named label files</title><para>
   <literal>Standard name label files</literal> are text files contain a list
   of equate statements setting up this equivalence of name, value, and label
   class. The text file is read, and any lines having the format
  </para></formalpara>
  <screen>
    <literal>&lt;code&gt;</literal> EQU
    <literal>&lt;value&gt; &lt;class&gt;</literal>
  </screen>
  <para>-just like an assembler equate directive - are processed.
  </para>
  <formalpara><title>&lt;label&gt;</title>
   <para>is a legal assembler name (up to 8 characters long),
   </para>
  </formalpara>
  <formalpara><title>&lt;value&gt;</title>
   <para>is either a decimal number or '<computeroutput>$</computeroutput>' 
    followed by a hexadecimal number,
   </para>
  </formalpara>
  <formalpara><title>&lt;class&gt;</title>
   <para>is the <literal>label class</literal>.  The label class, which must
    always be present as the first character of the comment field, may be one
    of '<computeroutput>A</computeroutput>' to
    '<computeroutput>Z</computeroutput>', '<computeroutput>^</computeroutput>',
    or '<computeroutput>!</computeroutput>'.
   </para>
  </formalpara>
  <para>Thus, a label file may be used to redefine the standard names for the
   ASCII control characters or the 'OS9' system functions. Any lines not having
   this strict '<computeroutput>EQU</computeroutput>' format are ignored, so
   the label file may contain comments, blank lines, or any other assembly code
   whatever.  Thus, normal <computeroutput>USE</computeroutput> or
   <computeroutput>LIB</computeroutput> text files may be used for label files.
  </para>
  <para>As an example, consider the definitions required to set up the
   <computeroutput>MOD</computeroutput> statement encountered in the previous
    section of standard labels. The class <computeroutput>L</computeroutput>
    values $1000, $000D, and $0050 should be named
    <computeroutput>LENGTH</computeroutput>,
    <computeroutput>NAMEPTR</computeroutput>, and
    <computeroutput>ENTRY</computeroutput>, respectively, and the class
    <computeroutput>D</computeroutput> value $0200 should be named
    <computeroutput>DATASIZE</computeroutput>. The label file could then be
  </para>
  <screen format="linespecific">
   LENGTH   EQU  $1000 L
   NAMEPTR  EQU  13    L
   ENTRY    EQU  $0050 L
   DATASIZE EQU  $200  D
  </screen>
  <para>
   Note in the above example that the values can either be hexadecial or
   or decimal.  Hex values must be precededed by
   '<computeroutput>$</computeroutput>'.  Spacing between fields is not
   critical.  For the spaces, you can use either spaces or tabs.
  </para>
  <para>Label files are particularly useful when disassembling code, produced
   under various operating systems, that references standard locations in those
   operating systems. Thus the default label file for <literal>OS/9</literal>
   code, <filename>Dynalbl</filename>, sets up the standard names for several
   absolute page 0 memory locations as class <computeroutput>X</computeroutput>
   labels. Also, the default label file for <literal>CoCo DOS</literal> code,
   <filename>CoColbl</filename>, and the default label files for
   <literal>FLEX</literal> code <filename>Flex9lbl</filename> and
   <filename>Flex0lbl</filename>, provide the standard names for many of the
   entry points and variables in <literal>CoCo DOS</literal>, <literal>FLEX
   9.0</literal> and <literal>FLEX 2.0</literal>, setting these up as class
   <computeroutput>L</computeroutput> or class
   <computeroutput>D</computeroutput> labels.
  </para>
  <note><para>The original label files on the CoCo by default went into /d0 (or
   /dd)/DEFS/,    but for this system, it will be different.
  </para></note>
  <para>Of the above files, depending upon which target system the program
   being disassembled was written for, the appropriate <literal>label
   file</literal> will be automatically processed (unless &odis; is
   specifically told not to do so.  In addition to these default label files,
   which are automatically processed, the &odis; package includes several other
   label files.  These files are not automatically processed, and must be
   manually selected, with the <command>S</command> option, if desired - and
   these files are usually quite useful. The first file,
   <filename>MiscOS9lbl</filename>, provides a number of standard names which
   are not meant as address references, but are instead to be used in immediate
   or indexed instructions. For instance, the standard names for the various
   <literal>OS-9</literal>  error codes are all set up as class
   <computeroutput>E</computeroutput> labels. When an <literal>OS/9</literal>
   error code is encountered in an instruction, assigning label class
   <command>E</command> to that particular instruction (usually addressing mode
   1 byte immediate) with <filename>MiscOS9lbl</filename>  being used will
   result in the standard error name being used.
  </para>
  <section><title>Defining your own Label Classes</title>
    <para>The real power of &odis; comes from the ability one has to define
      his own label classes.  By the use of label files, and additional classes,
      you are pretty free to define any disassemblies as you wish.
    </para>
    <para>You can use
      most of the alphabetical letters without conflicting with predefined
      usages.  You can inspect the <filename>*lbl</filename> files to see what
      letters are reserved.  If a particular file is not used, of course, any
      label classes defined there are free to be used.
    </para>
    <note>
      <para>
        Despite the fact that some labels are predefined, this does not
        prevent you from using the file and then change the name of any
        of these labels to something else (for whatever reason).  If a
        label is defined, and then later a file is read that contains a
        different name for that address, the first name is overwritten and
        the latter name is used.
      </para>
      <para>Some classes that <emphasis>are</emphasis> used are:
      </para>
      <informaltable frame="none">
        <tgroup cols="2"><colspec colwidth="1.0in"/>
          <tbody valign="top">
            <row>
              <entry><computeroutput>!</computeroutput></entry>
              <entry>Reserved for system calls</entry>
            </row>
            <row>
              <entry><computeroutput>D</computeroutput></entry>
              <entry>Data area for OS9 module - ROF Uninit dp data</entry>
            </row>
            <row>
              <entry><computeroutput>L</computeroutput></entry>
              <entry>This should probably <emphasis>never</emphasis> be used.
                It's for &odis;'s classification of <literal>program area
                labels</literal>
              </entry>
            </row>
            <row>
              <entry><computeroutput>B</computeroutput></entry>
              <entry><computeroutput>ROF only</computeroutput>
                Uninitialized non-dp data
              </enty>
            </row>
            <row>
              <entry><computeroutput>G</computeroutput></entry>
              <entry><computeroutput>ROF only</computeroutput>
                Initialized non-dp data
              </enty>
            </row>
            <row>
              <entry><computeroutput>H</computeroutput></entry>
              <entry><computeroutput>ROF only</computeroutput>
                Initialized dp data
              </enty>
            </row>
            <row>
              <entry><computeroutput>X</computeroutput></entry>
              <entry>Don't define anything as this.  This is &odis;'s
                classification for references to labels
                <literal>outside</literal> of the program area (besides data
                area for OS9).
              </entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <simpara>Aside from these, there's nothing else that's cast in stone
        regarding label classes.  However, as mentioned above, the default
        label files then use some of these for their definitions.  Please look
        these label files over and study them before defining label classes,
        keeping in mind which of these files you will be using.
      </simpara>
    </section>
    <note><para>The following paragraph is not applicable at this time.
    </para></note>
    <para>Other files include <filename>MiniFlexlbl</filename> is the standard
      label file for <literal>MINIFLEX (TM)</literal>, a predecessor of the
      <literal>FLEX</literal> operating system on the 6800.
      <filename>Swtbuglbl</filename> is the standard label file for
      <literal>SWTBUG (TM)</literal>, the system monitor in <literal>SWTPc
      6800</literal> computer systems. <filename>Sbuglbl</filename> is the
      standard label file for <literal>S-BUG (TM)</literal>, the system
      monitor in <literal>SWTPc 6809</literal> computer systems.
    </para>
  </section>
  <section><title>The System Name File</title>
    <para>The system name file is used by &odis; to supply the proper names to
     the function bytes used in <computeroutput>OS9</computeroutput> system
     calls, via the <computeroutput>OS9</computeroutput> opcode. For instance,
     the call to end a program, <computeroutput>OS9 F$Exit</computeroutput>, is
     actually <computeroutput>SWI2</computeroutput> followed by the byte value
     $06. To properly disassemble this code, &odis; must know that, after the
     <computeroutput>SWI2</computeroutput>, $06 means
     <computeroutput>F$Exit</computeroutput>.
    </para>
    <para>The system name file is a text file having the same format as a label
      file. All the labels in the file should be set up with the system name
      label class '<computeroutput>!</computeroutput>'.
    </para>
    <para>The system name file defaults to the file
      <filename>Sysnames</filename> for <literal>OS/9</literal> or
      <literal>Motorola</literal> format object code. For <literal>CoCo
      DOS</literal> or <literal>FLEX</literal> format, no system name file is
      used, and no OS9 opcodes will be produced. To allow <literal>OS9</literal>
      opcodes in a <literal>CoCo DOS</literal> or <literal>Flex</literal> format
      object files, you must manually include the sysnames file with the
      command <command>-s=Sysnames</command> yourself, either on the OS/9
      command line or in a command line in the <literal>command file</literal>.
    </para>
    <para>If you wish to add or change a system function name, you have several
      options. First, if the change is to be made only in a single program,
      it is best to include an entry in your own label file, with label class
      '<command>!</command>'. Second, if the changes are more extensive or more
      permanent, you may edit the default file.
    </para>
    <formalpara><title>The file miscos9lbl</title>
      <para>When disassembling <literal>OS9</literal> files, there's one other
        "standard" file that will usually be needed.  It's not read by default,
        you will need to specify it either on the command line or in the command
        file.  Please refer to it for its usage.  It defines several
        commonly-used classes, some of which are <literal>error codes (class
        E)</literal>, <literal>set/get stat codes (class S)</literal>, and
        several others.  The name is <filename>miscosolbl</filename>.
      </para>
    </formalpara>
  <section><title>Overriding Default Label Definitions</title>
    <para>If you include these default files, but wish to give any of these 
      values a different name, you can simply redefine them in a later label
      definition.  The default label files are scanned first, then the
      user-specified label files are scanned in the order in which they
      are specified, beginning with the files named on the command line.  No
      check is made when inserting a label def as to whether it's already
      been defined or not - well, actually, &odis; has already defined this
      label with its own definition (usually either class L, D, or X before
      the label files are read.  Therefore, if a label is defined, and later
      redefined, then this later definition is applied.
    </para>
    <simpara>This will work if you create your own custom label files.  You can
      override any of the "standard" label names in your custom file or
      override your own custom definitions in subsequent files.
    </simpara>
  </section>
 </section>
 <section><title>Disassembly Particulars</title>
  <para>&odis; is a two-pass disassembler. On the first pass, the object
    code is searched for all label references, and they are classifled. As
    detailed under other sections, the production of labels is governed by the
    use of label classes assigned to addressing modes. With this ability, it is
    possible to generate every label in the program. For instance, there are
    times when immediate loads of the <literal>X register</literal> should be
    disassembled as data, and times when they should be disassembled as labels.
    Proper adjustment of label classes to the <literal>immediate X addressing
    mode</literal> will separate the data loads from the true label loads.
  </para>
  <simpara>After the first pass is completed and all labels are identified and
    clasified, all label files are read and values are assigned. One caveat is
    that no check is made to determine if a label has already been assigned a
    standard label name. If a name has been given to a certain label in a class,
    if this is refined later in the same or a subsequent label file, then that
    name is replaced by the latter.
  </simpara>
  <simpara>The second pass creates the actual disassembly code, both the disk
    file and the output listing.
  </simpara>
  <para>The code produced by &odis; should always reassemble into code which
    is identical with the original source file<footnote><simpara>Once in a
    while, it won't come out exactly the same.  On occasion, a given assembler
    won't generate exactly the same mode, although, unless something is wrong
    with one of the assemblers, the code will do the same
    thing.</simpara></footnote> Some addressing modes, though, can generate
    either 8 bit references or 16 bit references, especially on the 6809. To
    ensure that such references will assemble to code with the same reference
    bit length, &odis; will generate forced addressing when required to produce
    the code being disassembled.  Some assemblers don't always generate the
    same result, however. This can be done only for the 6809, and is compatible
    with the forced addressing method expected by many assemblers.
  </para>
  <para>The disassembly process depends, to some extent, on the object code
    mode which is selected. When disassembling OS/9 code, &odis; expects the
    file to begin with the nine byte long module header. Both the header ID
    code or $87CD, and the header parity, must be present. Also, &odis; expects
    the file to be at least as long as indicated by the length entry in the
    header.  &odis; will generate both the <computeroutput>end</computeroutput>
    and the <computeroutput>emod</computeroutput> statements for an OS/9
    module. The module length and module name pointer variables in the header
    will be disassembled as labels having the class assigned globally to the
    relative addressing mode, which defaults to class L. The module type and
    revision bytes will be disassembled as two digit hexadecimal numbers.
  </para>
  <para>For ROF files, &odis; checks that the first bytes are the sync bytes
    ($62cd2387).  It generates <computeroutput>psect</computeroutput>,
    <computeroutput>vsect</computeroutput>, and all <computeroutput>ends
    </computeroutput> statements.
  </para>
  <para>&odis; will also check the top four bits of the type byte to
    determine the module type, and thus determine whether the module header
    should include the module entry point and the data area requirements. If
    the module is type 1, 2, $C, $D , or $E, then &odis; will read the next
    four bytes as part of the module header. The first two bytes will be
    disassembled as a label having the same class as that used for the length
    and name pointer words. The next two bytes are assumed to be the data area
    requirements. If this is a nonzero value, it will be disassembled as a
    label having the global direct page label class, which defaults to class
    <computeroutput>D</computeroutput>. Also, if this is nonzero, &odis; will
    generate the data area variables using <computeroutput>RMB</computeroutput>
    statements instead of <computeroutput>EQU</computeroutput> statements. Any
    variables having the same class as the data area size, and a value less
    than that of the size, will be included in these
    <computeroutput>RMB</computeroutput> definitions. &odis; will generate the
    <computeroutput>EMOD</computeroutput> statement in its proper position. The
    three byte CRC will not be checked, but will just be passed over. The
    object code must not end before the <computeroutput>EMOD</computeroutput>
    checksum, but can be longer if desired. &odis; will disassemble only a
    single module per object file. Any code following the
    <computeroutput>EMOD</computeroutput> is assumed to be non-module code.
  </para>
  <section><title>Particulars about RS Dos mode</title>
    <para>There are no especially outstanding quirks regarding the RS Dos
      mode.  You mainly need to go through and add several entries in the
      <literal>command file</literal> to get the addressing modes the way
      you like.  Many will need to be given the <literal>direct</literal>
      class.  Of course, you'll need to be able to acces the
      <command>cocolbl</command> file to get acceptable modes.
    </para>
    <para>There is one quirk that needs to be noted.  The assemblers -
      <command>edtasm</command>, at least - have a tendency to break up the
      file into smaller load blocks.  Of course there will be a break where
      a data segment appears in the midst of the program.
    </para>
    <para>In addition, I've noted where there are also breaks at random
      places, even in the middle of a string.  If you find that after declaring
      data boundaries, the disassembly stops short of the end and doesn't
      include all the files, check to see that you haven't declared a boundary
      overlapping a break.  The code could be fixed to allow for this, but it
      may incur some extensive modifying.  This may be addressed later.  To
      help in finding all the block addresses, A notice of the Load Address
      and length is sent to <literal>stderr</literal> during the disassembly
      process.  You can view this on the console, or redirect <literal>
      stderr</literal> to a file for a permanent record.  Of course this
      file will also contain any other error messages you get (hopefully
      none of these>
    </para>
    <para>There is one quirk in the disassembly.  The source will build, but
      it's a bit nontypical to normal programming.  If a program has an inline
      data area, the load block ends and another begins.  Also, the data
      area is not included in the program if a value is not assigned to
      it.  Therefore, &odis; will not have any data to process to get the
      proper <literal>fcb</literal>'s.  These addresses will be disassembled
      in the following manner:
    </para>
    <para>
      <programlisting>LABEL fcb *=&lt;number&gt;</programlisting>
    </para>
    <note><para>These will be generated <emphasis>after</emphasis> the
      <literal>org</literal> statement.</para>
    </note>
    <para>This is another thing that might be worked around, but for now,
      hopefully this will suffice.
    </para>
  </section>
 </section>
</section>
